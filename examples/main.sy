#!/usr/bin/env sylan

/*
 * If no package is specified, "main" is assumed. A `module-info.sy` file is not
 * required for the top level program as there is an inferred `main` module that
 * contains top-level programs.
 */
package main

/*
 * Most of those imports are already in the prelude and thus already imported:
 * `sylan.lang`. They are explicitly imported here to give an idea of the standard
 * package structure.
 */
import sylan.io.println
import sylan.util.toString.ToString
import sylan.util.collections.{HashMap, List}
import sylan.util.concurrency.Task
import sylan.util.datetime.ZonedDateTime
import sylan.util.optional.{Empty, Some}

void demoIteration() {
    /**
     * SyDocs can be written for code documentation. Unlike JavaDoc but similar
     * to Python, they go inside the item they describe rather than before it.
     */

    // Lambdas are declared with braces and an arrow.
    var highlight = { s -> `>> {s} <<` }

    1.to(5)
        .map(Number::doubled # ToString::toString # highlight)
        .forEach(println)

    // If a lambda is the only argument to a function or method, the parentheses can
    // be dropped.
    List(1, 2, 3).forEach { n ->

        /*
         * Backquoted strings allow interpolation. Only single symbols can be
         * interpolated; interpolating arbitrary expressions was purposely
         * omitted due to its ability to create cryptic one-liners.
         */
        println(`{n}`)
    }

    // The arrow can be dropped for no-argument lambdas.
    // Furthermore, single-parameter lambdas can use the `it` keyword instead.
    var quadruple = { it.doubled.doubled }

    123456789
        |> quadruple
        |> Object::toString
        |> highlight
        |> println

    var map = HashMap(
        "abc": 123,
        "def": 321,
        "ghi": 987,
    )
    map.forEach { key, value ->
        println(`{key}: {value}`)
    }

    do {
        var mutatingService = using Task {
            for n = 0 {
                var sender = select Task
                if n < 5 {
                    sender.send(Some(n))
                    continue n + 1
                } else {
                    sender.send(Empty)
                    continue n
                }
            }
        }

        5.times { counterService.send(currentTask) }
        while var Some(n) = select int {
            println(`{n}`)
        }
    }

    /*
     * Sylan does not allow scope shadowing. As functions are just
     * variables of a "function type", `factorial` would clash with the
     * top-level `factorial` function defined later on, hence the disambiguating
     * name `innerFactorial`.
     *
     * `for` is a cross between Java's enhanced-for loop and Scheme's named-let.
     */
    var innerFactorial = for n = 20, result = 1 {
        if n <= 0 {
            result
        } else {
            continue n - 1, n * result
        }
    }

    OUTER: for n = 10 {
        if 0 < n {
            for {

                // `continue` normally reiterates the current `for`, but an
                // explicit label allows going to an outer one instead.
                OUTER: continue n - 1
            }
        }
    }

    println(`factorial: {innerFactorial}`)
}

/*
 * All variables (including functions), packages, classes, fields,
 * and methods are private unless explicitly opened up with the `public`
 * keyword. If the developer wants to expose them openly but only to
 * its own module, they can use the `internal` keyword.
 *
 * As can be seen in this function and the previous, Sylan allows functions to
 * stand alone in packages without being tied to classes or interfaces.
 */
internal int factorial(int n) {
    switch n {
        0, 1 ->
            1
        n if n < 0 ->
            throw Exception("n cannot be less than 0")
        n ->
            /*
             * Guaranteed tail call elimination will ensure a stack overflow
             * does not occur.
             */
            factorial(n * (n - 1))
    }
}

ignorable internal int printFactorial(int n) {
    /*
     * Sylan does not allow callers to throw away non-`void` function or methods
     * results unless they're declared with the `ignorable` modifier.
     *
     * This makes sense when getting a return value is potentially useful but
     * not the entire reason behind invoking it.  Such a function or method can
     * be assumed to have side effects, with the exception of constant-time
     * operation NOPs or the like.
     */

    var result = factorial(n)
    println(result)

    /*
     * Sylan is an expression-oriented language, so everything returns a value
     * including loops and `if`s. Therefore, the last value is returned by
     * default. The lack of explicit `return`s mean there is always a single
     * exit point from a function or method: the last expression.
     */
    result
}

private void twice<N>(N n, N f(N)) where
    N : Number
{
    f(n) + f(n)
}

String doubled<N>(N n) where
    N : Add & ToString
{
    (n + n).toString()
}

Optional<int> demoContexts() {

    /*
     * Haskell programmers will recognise this as a monadic do notation, which
     * Sylan calls "contexts". Non-Haskell programmers will be glad to know that
     * this feature can make tangled code such as optionality-checking chains
     * and validation code much cleaner.
     */
    with {
        var a <- Some(5)
        doSomething()
        var b <- Empty()
        willNotBeRun()
    }
}

package counter {

    enum Message {
        Increment,
        Reset(int),
        Get,
    }

    public void start(Task sender, int n = 0) {
        switch select Message {
            .Increment ->
                start(sender, n + 1)
            .Reset(n) ->
                start(sender, n)
            .Get {
                sender.send(n)
                start(sender, n)
            }
            timeout 10.seconds ->
                throw Exception("timed out!")
        }
    }
}

interface Concatenate<T, Result = T> {
    public Result concatenate(T y)
}

interface Equals<T = Self> {
    public boolean equals(T other)

    /*
     * Sylan's interface methods can have bodies like Java 8's defender methods.
     * Unlike Java 8, private methods with bodies are also allowed with the
     * `default` keyword. Similar to C# but unlike Java, a default method body
     * in an interface can only be overridden if annotated with `virtual`.
     *
     * `virtual` is default for non-default methods since the lack of concrete
     * inheritance in Sylan means there is no other possible use case for them
     * except to be implemented by the implementor.
     */
    public default virtual notEquals(T other) {
        !equals(other)
    }
}

class Name {
    /**
     * Hashing, equality checking, and the constructor all just exist
     * automatically. They can still be manually overridden if necessary though.
     * `close` is also automatically implemented for classes that implement
     * `AutoCloseable`, the default implementation just closing all
     * `AutoCloseable` fields. This can also be overridden if the default
     * implementation makes no sense.
     */

    internal String firstName
    internal String lastName
}

class Account implements ToString, Concatenate<Account> {
    /**
     * Classes can implement interfaces but cannot extend other classes.
     * Interfaces can extend other interfaces though. Concrete inheritance
     * generally causes more problems that it's worth and type embedding plus a
     * more powerful interface system makes up for the difference.
     */

    /*
     * Embedding a field hoists all of its _accessible_ methods into
     * the class itself. Embedded methods take the lowest priority: methods in
     * the class itself and default methods in implementing interfaces both take
     * priority over embedded methods, although other embedded methods will
     * still call the embedder's method if calling it by name.

     * Embedded classes can implement methods for implementing interfaces on the
     * embedder's behalf, following the rules above.
     *
     * Note that no relationship whatsoever is established between the classes
     * after the embedding; there is no concrete subtyping in Sylan. It's solely
     * for DRY, a.k.a. Don't Repeat Yourself.
     *
     * The earlier embeddings take priority over the later ones, to be
     * consistent with the MRO of inheritance. Therefore, changing the order of
     * embeds can change behaviour.
     */
    embed Name name

    int ageInYears

    ZonedDateTime _expiry = ZonedDateTime.now() + 1.year

    public Account(String firstName, String lastName) {
        println("instantiating an Account...")

        /*
         * Constructors are the only place in Sylan where assignments are
         * allowed outside the context of a binding.
         */
        name.firstName = firstName
        name.lastName = lastName
        ageInYears = 35
    }

    public override String toString() {
        `{firstName} {lastName} is {ageInYears} years old`
    }

    public override Account concatenate(Account a) {
        var firstName = firstName.concat(a.firstName)
        var lastName = lastName.concat(a.lastName)

        Account(
            .firstName,
            .lastName,
            ageInYears = ageInYears + a.ageInYears,
        )
    }

    /*
     * Methods without any arguments can be called without parentheses,
     * effectively making them readonly properties or getters with syntactical
     * sugar. An important difference between Java getters and Sylan "getters"
     * is that Sylan's can shadow fields transparently, allowing fields to be
     * "upgraded" to getters transparently without breaking API compatibility.
     */

    public String name() {
        `{firstName} {lastName}`
    }

    public boolean locked() {
        expiry < ZonedDateTime.now
    }
}

/*
 * Type extensions allow modules to add their own features to an existing class
 * when imported. Note that this implements `Concatenate` again just with
 * different type parameters passed to `Concatenate`; Sylan considers these to
 * be two completely different implementations. This is a more disciplined
 * replacement for method overloading.
 */
extend class Account implements Concatenate<Account, Result = String> {

    public override String concatenate(This that) {
        `{firstName} {that.firstName}`
    }
}

void demoPatternMatching() {
    var account1 = Account(firstName = "Tom", lastName = "Smith")
    var matchingLastName = "Smith"

    if var Account(firstName, lastName = .matchingLastName) as account
            = account1 {
        println(`Matching first name: {firstName}`)
        println(`Matching account: {account}`)
    }

    switch account1 {

        Account(locked = true), Account(firstName = "unlucky") ->
            println("LOCKED!")

        Account(expiry) if expiry < ZonedDateTime.now ->
            println("ALSO LOCKED")

        default {
            println("NOT LOCKED: ")
            println(account1)
        }

        /*
         * Switches are expressions, support multiple cases, can do pattern
         * matching, and have support for conditional "guards".
         */
    }
}

/*
 * Aliasing of various constructs to allow easy code repair during large-scale
 * refactoring. Any item in any module can be aliased, which can ease module
 * versioning where new major module versions are effectively different modules.
 */
alias counter2 = counter
alias Person = Account
alias Showable = ToString
alias factorial2 = factorial

int maxBound = 5

void demoClosures() {
    var x = 5

    var account1 = Account(
        firstName = "Tom",
        lastName = "Smith",
        ageInYears = 15,
    )

    var firstName = "Tom"
    var lastName = "Smith"
    var age = 25
    var account2 = Account(.firstName, .lastName, ageInYears = age)

    var f = { a ->
        println(a.toString())
    }

    f(account1)
    f(account2(firstName = "Emma"))

    var g = { a ->
        println("returning an account")
        a
    }

    var z = g(account1)

    var n = twice(3, { x -> x * 2 })
    println(`n == {n}`)
}

class NumericLiteralsClass implements ToString {

    // Non-overflowable numbers.
    int a = 5
    uint b = 5u
    decimal c = 10.0

    // Overflowable, machine-width numbers.
    byte d = 5u8
    uint16 e = 11u16
    uint32 f = 12u32
    uint64 g = 13u64
    int8 h = 15s8
    short i = 13s16
    int32 j = 7s
    long k = 7s64
    float l = 12f
    double m = 8f64

    public override String toString() {
        `{a}{b}{c}{d}{e}{f}{g}{h}{i}{j}{k}{l}{m}`
    }
}

class AutoCloseableDemo implements AutoCloseable {

    public AutoCloseableDemo() {
        println("Opened")
    }

    public override void close() {
        println("Closed")
    }
}

void demoAutoCloseables() {

    /*
     * Sylan, like Erlang and Go, strongly discourages catching exceptional
     * problems on a routine basis - if something is truly "exceptional" then
     * the developer wouldn't have thought of a meaningful response to it.
     * Instead it encourages assertive programming through a "happy path" and
     * using supervisor tasks to allow the system to heal from unexpected
     * failures.
     *
     * Sylan does not offer `try`/`catch` for this reason, and also to ensure
     * that exception-driven control flow isn't possible.
     *
     * However, there still needs to be a strategy regarding closing resources
     * in tasks that have had unexpected failures. Sylan offers `AutoClosable`
     * types and the `using` keyword for this, which are a sort of middle ground
     * between C#'s `IDisposable` and its `using` keyword, and Go's `defer`
     * keyword.
     *
     * If an `AutoCloseable` type is prefixed with the `using` keyword, its
     * `close` method is invoked at the end of the scope _even if the
     * code in the scope completely fails unexpectedly_. The closing is done in
     * the reverse order that they are set up. If any `defer`d `close` methods
     * themselves fail, all other deferred calls are given a chance to run too,
     * and all errors are accumulated into one and rethrown once they're all
     * finished.
     */

    println("Entering scope")
    do {
        var closeable = using AutoCloseableDemo()
        println("Using closeable")
    }
    println("Leaving scope")

    // Prints "Entering scope", "Opened", "Using closeable", "Closed", and finally "Leaving scope".
}

void demo() {
    demoIteration()

    printFactorial(42)
    var x = twice(4, doubled)
    println(`{x}`)

    demoContexts()
    demoPatternMatching()
    demoClosures()

    println(NumericLiteralsDemo().toString())

    demoAutoCloseable()
}

/*
 * Top-level code is allowed, but only in the main package within the main
 * module. Code in other packages must be in functions or methods.
 */

var optionalString = Some("test string")
if var Some(s) = optionalString {
    println(s)
}

var c = Task { counter.start(currentTask) }
5.times { c.send(counter.Message.Increment()) }

c.send(counter.Message.Get())
c.send(counter.Message.Increment())
c.send(counter.Message.Get())

// Should print 5 and then 6.
2.times {
    var n = select int
    println(`{n}`)
}

print("""
3 or more quotes can be used to create a custom string delimiter.
This allows escaping almost any embedded content with few problems.
This works with interpolated and raw strings too.
""")

println(r"Raw string in which escapes characters are now read literally: \n\r")

var n = 4

println(```
Multiline interpolated strings: {n}
```)

var x = do {
    println("Returning 5 to be bound as x...")
    5
}
println(`{x}`)

/*
  A multiline comment.

  /*
    A nested multiline comment.
  */
*/

demo()
