#!/usr/bin/env sylan

// If no package is specified, "main" is assumed. A `module-info.sy` file is not
// required for the top level program as there is an inferred `main` module that
// contains top-level programs.
package main

// Most of those imports are already in the prelude and thus already imported:
// `sylan.lang`. They are explicitly imported here to give an idea of the standard
// package structure.
import sylan.io.println
import sylan.util.toString.ToString
import sylan.util.collections.{HashMap, List}
import sylan.util.concurrency.Task
import sylan.util.datetime.ZonedDateTime
import sylan.util.optional.{Empty, Some}

void fizzBuzz(int n) {

    // Sylan supports blocks, syntax for passing a lambda as a final argument to
    // an invocable. Note the use of `it` as a shorthand for one-argument
    // blocks.
    1.upTo(n).forEach -> {
        println(
            switch {
                0 == (it % 15) { "FizzBuzz" }
                0 == (it % 5) { "Fizz" }
                0 == (it % 3) { "Buzz" }
                default { it }
            }
        )
    }
}

fizzBuzz(100)

/**
 * SyDocs can be written for code documentation.
 */
void demoIteration() {

    var highlight = -> s { `>> {s} <<` }

    // The # operator composes invocables together.
    1.upTo(5)
        .map(::Number.doubled # ::ToString.toString # ::highlight)
        .forEach(::println)

    // Sylan supports field-looking getters and transparently upgrading an
    // expression to a lazy computation, both of which mandate no parentheses
    // for no-argument invocables. Use the :: operator without a prefix to pick
    // up these invocables as first-class values. Combine it with the dot
    // operator to refer to a method of a type.

    // Lambdas can be passed outside of calling parentheses when they are the
    // final argument.
    List(1, 2, 3).forEach -> n {

        /*
         * Backquoted strings allow interpolation. Only single symbols can be
         * interpolated; interpolating arbitrary expressions was purposely
         * omitted due to its ability to create cryptic one-liners.
         */
        println(`{n}`)
    }

    var quadruple = -> { it.doubled.doubled }

    123456789
        |> ::quadruple
        |> ::Object.toString
        |> ::highlight
        |> ::println

    var map = HashMap(
        "abc": 123,
        "def": 321,
        "ghi": 987,
    )
    map.forEach -> key, value {
        println(`{key}: {value}`)
    }

    do -> {
        var counterService = using Task -> {
            for n = 0 {
                var sender = select Task {
                    default { it }
                }
                if n < 5 {
                    sender.send(Some(n))
                    continue(n + 1)
                } else {
                    sender.send(Empty)
                    continue(n)
                }
            }
        }

        5.times -> {
            counterService.send(currentTask)
        }
        while var Some(n) = select int { default { it } } {
            println(`{n}`)
        }
    }

    /*
     * Sylan does not allow scope shadowing. As functions are just
     * variables of a "function type", `factorial` would clash with the
     * top-level `factorial` function defined later on, hence the disambiguating
     * name `innerFactorial`.
     *
     * `for` is a cross between Java's enhanced-for loop and Scheme's named-let.
     */
    var innerFactorial = for var n = 20, var result = 1 {
        if n <= 0 {
            result
        } else {

            // Continue, like `it`, is a keyword representing an implicit
            // variable. In this case it stands for the inner-most
            // unlabelled for loop.
            continue(n - 1, n * result)
        }
    }

    for outer var n = 10 {
        if 0 < n {
            for {

                // This for loop is labelled as "outer", so that is available
                // to call as a function if iteration is desired. That allows
                // it to skip the inner `for` here; `continue` is this context
                // would cause an infinite loop.
                outer(n - 1)
            }
        }
    }

    println(`factorial: {innerFactorial}`)
}

/*
 * All variables (including functions), packages, classes
 * and methods are private unless explicitly opened up with the `public`
 * keyword. If the developer wants to expose them openly but only to
 * its own module, they can use the `internal` keyword.
 *
 * As can be seen in this function and the previous, Sylan allows functions to
 * stand alone in packages without being tied to classes or interfaces.
 */
internal int factorial(int n) {
    switch n {
        0, 1 {
            1
        }
        n if n < 0 {
            throw Exception("n cannot be less than 0")
        }
        n {
            /*
             * Guaranteed tail call elimination will ensure a stack overflow
             * does not occur.
             */
            factorial(n * (n - 1))
        }
    }
}

ignorable internal int printFactorial(int n) {
    /*
     * Sylan does not allow callers to throw away non-`void` function or methods
     * results unless they're declared with the `ignorable` modifier.
     *
     * This makes sense when getting a return value is potentially useful but
     * not the entire reason behind invoking it.  Such a function or method can
     * be assumed to have side effects, with the exception of constant-time
     * operation NOPs or the like.
     */

    var result = factorial(n)
    println(result)

    /*
     * Sylan is an expression-oriented language, so everything returns a value
     * including loops and `if`s. Therefore, the last value is returned by
     * default. The lack of explicit `return`s mean there is always a single
     * exit point from a function or method: the last expression.
     */
    result
}

void twice<N>(N n, N f(N)) where
    N : Number
{
    f(n) + f(n)
}

String doubled<N>(N n) where
    N : Add & ToString
{
    (n + n).toString()
}

/**
 * Sylan uses concrete implementations of interfaces by default when they're
 * used as typed directly. To get dynamic dispatch, use the virtual keyword
 * like so:
 *
 *     void printNumber(virtual Number n) {
 */
void printNumber(Number n) {
    println(`{n}`)
}

Optional<int> demoContexts() {

    /*
     * Haskell programmers will recognise this as a monadic do notation, which
     * Sylan calls "contexts". Non-Haskell programmers will be glad to know that
     * this feature can make tangled code such as optionality-checking chains
     * and validation code much cleaner.
     */
    with {
        var a <- Some(5)
        println("Doing something.")

        // All invocables can drop parentheses if calling with no arguments.
        // This is actually how getters work behind the scenes and why Sylan
        // needn't allow public fields as a feature.
        var b <- Empty

        println("Will not be run.")

        Empty
    }
}

package counter {

    enum Message {
        Increment,
        Reset(int),
        Get,
    }

    public void start(Task sender, int n = 0) {
        select Message {
            .Increment {
                start(sender, n + 1)
            }
            .Reset(n) {
                start(sender, n)
            }
            .Get {
                sender.send(n)
                start(sender, n)
            }
            timeout 10.seconds {
                throw Exception("timed out!")
            }
        }
    }
}

interface Concatenate<T> {
    public T concatenate(T y)
}

interface Equals<T> {
    public boolean equals(T other)

    /*
     * Sylan's interface methods can have bodies like Java 8's defender methods.
     * Unlike Java 8, private methods with bodies are also allowed with the
     * `default` keyword. Similar to C# but unlike Java, a default method body
     * in an interface can only be overridden if annotated with `virtual`.
     *
     * `virtual` is default for non-default methods since the lack of concrete
     * inheritance in Sylan means there is no other possible use case for them
     * except to be implemented by the implementor.
     */
    public default virtual notEquals(T other) {
        !equals(other)
    }
}

/**
 * Hashing, equality checking, and the constructor all just exist
 * automatically. They can still be manually overridden if necessary though.
 * `close` is also automatically implemented for classes that implement
 * `AutoCloseable`, the default implementation just closing all
 * `AutoCloseable` fields. This can also be overridden if the default
 * implementation makes no sense.
 */
class Name {
    internal String firstName
    internal String lastName
}

/**
 * Classes can implement interfaces but cannot extend other classes.
 * Interfaces can extend other interfaces though. Concrete inheritance
 * generally causes more problems that it's worth and type embedding plus a
 * more powerful interface system makes up for the difference.
 */
class Account implements ToString, Concatenate<Account> {


    /*
     * Embedding a field hoists all of its _accessible_ methods into
     * the class itself. Embedded methods take the lowest priority: methods in
     * the class itself and default methods in implementing interfaces both take
     * priority over embedded methods, although other embedded methods will
     * still call the embedder's method if calling it by name.
     *
     * Embedded classes can implement methods for implementing interfaces on the
     * embedder's behalf, following the rules above.
     *
     * Note that no relationship whatsoever is established between the classes
     * after the embedding; there is no concrete subtyping in Sylan. It's solely
     * for DRY, a.k.a. Don't Repeat Yourself.
     *
     * The earlier embeddings take priority over the later ones, to be
     * consistent with the MRO of inheritance. Therefore, changing the order of
     * embeds can change behaviour.
     */
    embed Name name

    internal int ageInYears

    ZonedDateTime expiry = ZonedDateTime.now() + 1.year

    public Account(String firstName, String lastName) {
        println("instantiating an Account...")

        /*
         * Constructors are the only place in Sylan where assignments are
         * allowed outside the context of a binding. Each field must be set
         * once, and exactly once.
         *
         * Note that this class elsewhere uses the auto-generated getters for
         * these fields but assignments in constructor must set the underlying
         * fields via `this` directly.
         */
        this.name.firstName = firstName
        this.name.lastName = lastName
        this.ageInYears = 35
    }

    public override String toString() {
        `{firstName} {lastName} is {ageInYears} years old`
    }

    public override Account concatenate(Account other) {
        var firstName = firstName.concat(other.firstName)
        var lastName = lastName.concat(other.lastName)

        Account(
            .firstName,
            .lastName,
            ageInYears = ageInYears + other.ageInYears,
        )
    }

    /*
     * Methods without any arguments can be called without parentheses,
     * effectively making them readonly properties or getters with syntactical
     * sugar. An important difference between Java getters and Sylan "getters"
     * is that Sylan's can replace fields transparently, allowing fields to be
     * "upgraded" to getters transparently without breaking API compatibility.
     *
     * Getters are automatically generated for fields with the same
     * accessibility.
     *
     * Fields must always be accessed via `this`, but as even private fields
     * autogenerate getter methods of the same accessibility, methods can use
     * the getter in practice e.g. `name` rather than `this.name`.
     *
     * `this` is intended to only be used explicitly in explicit getter
     * implementations or when assigning in constructors.
     */

    public String name() {
        `{firstName} {lastName}`
    }

    public boolean locked() {
        expiry < ZonedDateTime.now
    }
}

/*
 * Type extensions allow modules to add their own features to an existing class
 * when imported. Note that this implements `Concatenate` again just with
 * different type parameters passed to `Concatenate`; Sylan considers these to
 * be two completely different implementations. This is a more disciplined
 * replacement for method overloading.
 */
extend class Account implements Concatenate<Account, Result = String> {

    public override String concatenate(This that) {
        `{firstName} {that.firstName}`
    }
}

void demoPatternMatching() {
    var account1 = Account(firstName = "Tom", lastName = "Smith")
    var matchingLastName = "Smith"

    if var Account(firstName, lastName = .matchingLastName) as account
            = account1 {
        println(`Matching first name: {firstName}`)
        println(`Matching account: {account}`)
    }

    switch account1 {

        Account(locked = true), Account(firstName = "unlucky") {
            println("LOCKED!")
        }

        Account(expiry) if expiry < ZonedDateTime.now {
            println("ALSO LOCKED")
        }

        default {
            println("NOT LOCKED: ")
            println(account1)
        }

        /*
         * Switches are expressions, support multiple cases, can do pattern
         * matching, and have support for conditional "guards".
         */
    }
}

/*
 * Aliasing of various constructs to allow easy code repair during large-scale
 * refactoring. Any item in any module can be aliased, which can ease module
 * versioning where new major module versions are effectively different modules.
 */
alias counter2 = counter
alias Person = Account
alias Showable = ToString
alias factorial2 = factorial

int maxBound = 5

void demoClosures() {
    var x = 5

    var account1 = Account(
        firstName = "Tom",
        lastName = "Smith",
        ageInYears = 15,
    )

    var firstName = "Tom"
    var lastName = "Smith"
    var age = 25
    var account2 = Account(.firstName, .lastName, ageInYears = age)

    var f = -> { println(it.toString) }

    f(account1)
    f(account2(firstName = "Emma"))

    var g = -> {
        println("returning a value")
        it
    }

    var z = g(account1)

    var n = twice(3) -> { it * 2 }
    println(`n == {n}`)
}

class NumericLiteralsClass implements ToString {

    // Non-overflowable numbers.
    int a = 5
    uint b = 5u
    decimal c = 10.0

    // Overflowable, machine-width numbers.
    byte d = 5u8
    uint16 e = 11u16
    uint32 f = 12u32
    uint64 g = 13u64
    int8 h = 15s8
    short i = 13s16
    int32 j = 7s
    long k = 7s64
    float l = 12f
    double m = 8f64

    public override String toString() {
        `{a}{b}{c}{d}{e}{f}{g}{h}{i}{j}{k}{l}{m}`
    }
}

class AutoCloseableDemo implements AutoCloseable {

    public AutoCloseableDemo() {
        println("Opened")
    }

    public override void close() {
        println("Closed")
    }
}

void demoAutoCloseables() {

    /*
     * Sylan, like Erlang and Go, strongly discourages catching exceptional
     * problems on a routine basis - if something is truly "exceptional" then
     * the developer wouldn't have thought of a meaningful response to it.
     * Instead it encourages assertive programming through a "happy path" and
     * using supervisor tasks to allow the system to heal from unexpected
     * failures.
     *
     * Sylan does not offer `try`/`catch` for this reason, and also to ensure
     * that exception-driven control flow isn't possible.
     *
     * However, there still needs to be a strategy regarding closing resources
     * in tasks that have had unexpected failures. Sylan offers `AutoClosable`
     * types and the `using` keyword for this, which are a sort of middle ground
     * between C#'s `IDisposable` and its `using` keyword, and Go's `defer`
     * keyword.
     *
     * If an `AutoCloseable` type is prefixed with the `using` keyword, its
     * `close` method is invoked at the end of the scope _even if the
     * code in the scope completely fails unexpectedly_. The closing is done in
     * the reverse order that they are set up. If any `defer`d `close` methods
     * themselves fail, all other deferred calls are given a chance to run too,
     * and all errors are accumulated into one and rethrown once they're all
     * finished.
     */

    println("Entering scope")
    do -> {
        var closeable = using AutoCloseableDemo
        println("Using closeable")
    }
    println("Leaving scope")

    // Prints "Entering scope", "Opened", "Using closeable", "Closed", and finally "Leaving scope".
}

void demo() {
    // As mentioned above, all invocables can omit parentheses if they have
    // zero parameters. This is primarily for getters, but should also be used
    // for Pascal-procedure-style invocations just for consistency. That
    // includes constructors, methods, lambdas, and functions.

    demoIteration

    printFactorial(42)
    var x = twice(4, ::doubled)
    println(`{x}`)

    demoContexts
    demoPatternMatching
    demoClosures

    println(NumericLiteralsDemo.toString)

    demoAutoCloseable
}

/*
 * Top-level code is allowed, but only in the main package within the main
 * module. Code in other packages must be in functions or methods.
 *
 * Top-level declarations must usually be explicitly typed, but type inference
 * with `var` is allowed for the main package, in which case they are just
 * type-inferred local variables for the top-level program which are private
 * to the `main` package.
 */

var optionalString = Some("test string")
if var Some(s) = optionalString {
    println(s)
}

var c = Task -> { counter.start(currentTask) }
5.times -> { c.send(counter.Message.Increment) }

c.send(counter.Message.Get)
c.send(counter.Message.Increment)
c.send(counter.Message.Get)

// Should print 5 and then 6.
2.times -> {
    var n = select int {
        default { it }
    }
    println(`{n}`)
}

print("""
3 or more quotes can be used to create a custom string delimiter.
This allows escaping almost any embedded content with few problems.
This works with interpolated and raw strings too.
""")

println(r"Raw string in which escapes characters are now read literally: \n\r")

var n = 4

println(```
Multiline interpolated strings: {n}
```)

var x = do -> {
    println("Returning 5 to be bound as x...")
    5
}
println(`{x}`)

/*
  A multiline comment.

  /*
    A nested multiline comment.
  */
*/

demo
