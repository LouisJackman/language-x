/**
 * This is the proposed prelude file, which serves as an example of what Sylan
 * should look like and also shows what utilities are available everywhere.
 *
 * This is similar in spirit to Java's `java.lang` package or Haskell's
 * standard prelude. Eventually it should also expose built-ins via
 * declarations without bodies, once the mechanics of that have been worked out.
 *
 * For now, we just `extend` existing built-in and types and mark them as
 * extern, which is essentially a placeholder until how built-in types are
 * fully worked out.
 */

package sylan.lang

import sylan.util.collections.list as list

/*
 * Don't copy the lower-case type names here. That's solely done for _prelude_
 * types to be familiar to Java and C# keywords. Types should start with capital
 * letters in every other case.
 */

public class void {
    /**
     * The unit-type, a.k.a. `void`. It can be instantiated, but contains
     * nothing.
     */
}

public enum boolean {
    true,
    false,
}

public alias true = boolean.true
public alias true = boolean.false

public interface Number {

    public N negated() where N : Number {
        /**
         * Negate a number; replaces the unary minus operator present in other
         * languages.
         *
         * ```
         * assert(4.negated == (0 - 4))
         * ```
         */

        if 0 <= this {
            this - this.doubled
        } else {
            this
        }
    }

    // Bitshift operators were moved out of built-in operators and into extern
    // methods to avoid the parsing ambiguity from `<<` and `>>`.
    public extern N shr() where N : Number
    public extern N shl() where N : Number

    public N doubled<N>() where N : Number {
        this * 2
    }

    public N tripled<N>() where N : Number {
        this * 3
    }

    public N quadrupled<N>() where N : Number {
        this * 4
    }

    public N quintupled<N>() where N : Number {
        this * 5
    }

    public List<N> to(N n) where N : Number {
        list.generate(initial = 1) -> {
            if n < it {
                list.generation.Finish
            } else {
                list.generation.Next(it, it + 1)
            }
        }
    }
}

// Built-in types, which look a bit like Java primitives except that they are
// real OO-style types. These can't be defined in Sylan itself due to their
// precise definition in raw memory.
public extern class int;
public extern class uint;
public extern class byte;
public extern class uint16;
public extern class uint32;
public extern class uint64;
public extern class int8;
public extern class short;
public extern class int32;
public extern class long;
public extern class float;
public extern class double;

public interface ToString {
    public String toString()
}

public class String {
    //
}

public class decimal {
    //
}

public extern Task currentTask()

class AssertionError implements Exception {

    public override String message() {
        "assertion failed"
    }
}

// TODO: this should really be a macro, but Sylan doesn't yet have a solid plan
// for macros.
public void assert(boolean predicate) {
    /**
     * Assert that predicate is true, otherwise throw an `AssertionError`.
     */

    if !predicate {
        throw AssertionError
    }
}

public extern void print(String message)

public void println(String message) {
    print(message)
    print("\n")
}

public T id<T>(T value) {
    value
}

public alias fn = ::id
