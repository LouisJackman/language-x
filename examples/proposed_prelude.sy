/**
 * This is the proposed prelude file, which serves as an example of what Sylan
 * should look like and also shows what utilities are available everywhere.
 *
 * This is similar in spirit to Java's `java.lang` package or Haskell's
 * standard prelude. Eventually it should also expose built-ins via
 * declarations without bodies, once the mechanics of that have been worked out.
 *
 * For now, we just `extend` existing built-in and types and mark them as
 * extern, which is essentially a placeholder until how built-in types are
 * fully worked out.
 */

package sylan.lang

import sylan.util.collections.list as list

class public Void {
    /**
     * The unit-type, a.k.a. `void`. It can be instantiated, but contains
     * nothing.
     */
}

enum public Boolean {
    True,
    False;


    var public extern && operator (other This)
    var public extern || operator (other This)
}

class public extern Invokable<Result, Args...>

extend class Invokable<Result, Args...> {

    var public extern |> operator <T> (other (Result) T) T
    var public extern # operator <T> (other (Result) T) (Args...) T
}

var public True = Boolean.true
var public False = Boolean.false

interface public Number {

    // Natively-defined arithmetic operators.
    var public extern + operator (other This) This
    var public extern - operator (other This) This
    var public extern / operator (other This) This
    var public extern % operator (other This) This
    var public extern * operator (other This) This
    var public extern ** operator (other This) This

    // Natively-defined bitwise operators.
    var public extern & operator (other This) This
    var public extern ^ operator (other This) This
    var public extern bitnot() This

    var public extern < operator (other This) This
    var public extern <= operator (other This) This
    var public extern == operator (other This) This
    var public extern != operator (other This) This
    var public extern > operator (other This) This
    var public extern >= operator (other This) This

    var public negated = -> () This {
        /**
         * Negate a number; replaces the unary minus operator present in other
         * languages.
         *
         * ```
         * assert(4.negated == (0 - 4))
         * ```
         */

        if 0 <= this {
            this - this.doubled
        } else {
            this
        }
    }

    // Bitshift operators with angle brackets were moved out of built-in
    // operators and into extern methods to avoid the parsing ambiguity from
    // `<<` and `>>`.
    public extern shr() Number
    public extern shl() Number

    var public doubled = -> () Number {
        this * 2
    }

    var public tripled = -> () Number {
        this * 3
    }

    var public quadrupled = -> () Number {
        this * 4
    }

    var public quintupled = -> () Number {
        this * 5
    }

    var public to = -> <N: Number> (n N) List<N> {
        list.generate(initial = 1) -> {
            if n < it {
                list.generation.Finish
            } else {
                list.generation.Next(it, it + 1)
            }
        }
    }
}

// Built-in types, which look a bit like Java primitives except that they are
// real OO-style types. These can't be defined in Sylan itself due to their
// precise definition in raw memory.
class public extern Int
class public extern UInt
class public extern Byte
class public extern UInt16
class public extern UInt32
class public extern UInt64
class public extern Int8
class public extern Short
class public extern Int32
class public extern Long
class public extern Float
class public extern Double

interface public ToString {
    var public toString() String
}

class public String {
    //
}

class public Decimal {
    //
}

var public extern currentTask() Task

class AssertionError implements Exception {

    var public override message = -> () String {
        "assertion failed"
    }
}

// TODO: this should really be a macro, but Sylan doesn't yet have a solid plan
// for macros.
var public assert = -> (predicate Boolean) Void {
    /**
     * Assert that predicate is true, otherwise throw an `AssertionError`.
     */

    if !predicate {
        throw AssertionError
    }
}

var public extern print(message String) Void

var public println = -> (message String) Void {
    print(message)
    print("\n")
}

var public id = -> <T> (value T) T {
    value
}

