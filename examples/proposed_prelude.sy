/**
 * This is the proposed prelude file, which serves as an example of what Sylan
 * should look like and also shows what utilities are available everywhere.
 *
 * This is similar in spirit to Java's `java.lang` package or Haskell's
 * standard prelude. Eventually it should also expose built-ins via
 * declarations without bodies, once the mechanics of that have been worked out.
 *
 * For now, we just `extend` existing built-in and types and mark them as
 * extern, which is essentially a placeholder until how built-in types are
 * fully worked out.
 */

package sylan.lang

import sylan.util.collections.list as list

class public Void {
    /**
     * The unit-type, a.k.a. `void`. It can be instantiated, but contains
     * nothing.
     */
}

enum public Boolean {
    True,
    False;

    fun public extern operator && (other This)
    fun public extern operator || (other This)
}

fun public extern !(b Boolean) Boolean

class public extern Invokable[Result, Args...]

extend class Invokable[Result, Args...] {

    fun public extern operator |> [T](other (Result) T) T
    fun public extern operator ~ [T](other (Result) T) (Args...) T
}

interface public Number {

    // Natively-defined arithmetic operators.
    fun public extern operator + (other This) This
    fun public extern operator - (other This) This
    fun public extern operator / (other This) This
    fun public extern operator % (other This) This
    fun public extern operator * (other This) This
    fun public extern operator ** (other This) This

    // Natively-defined bitwise operators.
    fun public extern operator & (other This) This
    fun public extern operator ^ (other This) This

    fun public extern operator < (other This) This
    fun public extern operator <= (other This) This
    fun public extern operator == (other This) This
    fun public extern operator != (other This) This
    fun public extern operator > (other This) This
    fun public extern operator >= (other This) This

    // Bitshift operators with angle brackets were moved out of built-in
    // operators and into extern methods to avoid the parsing ambiguity from
    // `<<` and `>>`.
    fun public extern shr Number
    fun public extern shl Number

    fun public negate This {
        /**
         * Negate a number; replaces the unary minus operator present in other
         * languages.
         *
         * ```
         * assert(4.negate == (0 - 4))
         * ```
         */

        if 0 <= this {
            this - this.doubled
        } else {
            this
        }
    }

    fun public double Number {
        this * 2
    }

    fun public triple Number {
        this * 3
    }

    fun public quadruple Number {
        this * 4
    }

    fun public quintuple Number {
        this * 5
    }

    fun public to(n Number) List[Number] {
        list.generate(initial: 1) -> {
            if n < it {
                list.generation.Finish
            } else {
                list.generation.Next(it, it + 1)
            }
        }
    }
}

fun public extern bitnot[N Number](n N) N

// Built-in types, which look a bit like Java primitives except that they are
// real OO-style types. These can't be defined in Sylan itself due to their
// precise definition in raw memory.
class public extern Int
class public extern UInt
class public extern Byte
class public extern UInt16
class public extern UInt32
class public extern UInt64
class public extern Int8
class public extern Short
class public extern Int32
class public extern Long
class public extern Float
class public extern Double

interface public ToString {
    fun public toString String
}

class public String {
    //
}

class public Decimal {
    //
}

fun public extern currentTask Task

class AssertionError implements Exception {

    fun public override message String {
        "assertion failed"
    }
}

// TODO: this should really be a macro, but Sylan doesn't yet have a solid plan
// for macros.
fun public assert(predicate Boolean) {
    /**
     * Assert that predicate is true, otherwise throw an `AssertionError`.
     */

    if !predicate {
        throw AssertionError
    }
}

fun public extern print(message String)

fun public println(message String) {
    print(message)
    print("\n")
}

fun public id[T](value T) T {
    value
}

fun public constant[T](value T) () T {
    -> { value }
}

