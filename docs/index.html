<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Sylan</title>
  <meta
      name="description"
      content="An experimental programming language project to investigate what a spiritual successor to Java and C# might look like."
  >
  <meta name="author" content="Louis Jackman">
  <meta name="keywords" content="sylan,programming language,plt">
  <style>

body {
    line-height: 25px;
    margin: 0 auto;
    max-width: 70ex;
}

h1 {
    text-align: center;
}

pre {
    overflow: auto;
    border: 1px solid black;
    padding: 10px;
    height: 60em;
    overflow: scroll;
}

li.done::after {
    content: " [DONE]";
    color: green;
}

  </style>
</head>
<body>
<header>
<h1>Sylan</h1>
  <a href="https://github.com/LouisJackman/sylan">
    <img
      style="position: absolute; top: 0; right: 0; border: 0;"
      src="forkme_right_darkblue_121621.png"
      alt="Fork me on GitHub"
    >
  </a>
  <p>
    Sylan is an experimental programming language project to investigate what a
    spiritual successor to Java and C# might look like.
  </p>

  <h2>Contents</h2>

  <nav>
    <ul>
      <li><a href="#example">Example</a></li>
      <li><a href="#synopsis">Synopsis</a></li>
      <li><a href="#todo">TODO</a></li>
      <li><a href="#goals">Goals</a></li>
      <li>
        <a href="#details">Details</a>
        <ul>
          <li><a href="#details-modules-and-packages">Modules and Packages</a></li>
          <li><a href="#details-accessibility-levels">Accessibility Levels</a></li>
          <li><a href="#details-types">Types</a></li>
            <li><a href="#details-type-hierarchy">Type Hierarchy</a></li>
            <li><a href="#details-type-embedding">Type Embedding</a></li>
            <li><a href="#details-type-inference">Type Inference</a></li>
          <li><a href="#details-items-and-expressions">Items and Expressions</a></li>
          <li><a href="#details-pattern-matching">Pattern Matching</a></li>
          <li>
            <a href="#details-matching-in-switch-and-select">
              Matching in Switch and Select
            </a>
          </li>
          <li><a href="#details-invocations">Invocations</a></li>
          <li>
            <a href="#details-compile-time-metaprogramming">
              Compile-time Metaprogramming
            </a>
          </li>
          <li>
            <a href="#details-runtime-structure-information">
              Runtime Structure Information
            </a>
          </li>
            <li><a href="#details-resource-management">Resource Management</a></li>
          <li><a href="#details-the-runtime">The Runtime</a></li>
          <li><a href="#details-interoperability">Interoperability</a></li>
          <li><a href="#details-standard-library">Standard Library</a></li>
          <li><a href="#details-to-consider">To Consider</a></li>
        </ul>
      </li>
      <li><a href="#implementation-details">Implementation Details</a></li>
    </ul>
  </nav>
</header>
<main>

<h2 id="example">Example</h2>

<pre>
#!/usr/bin/env sylan

/*
 * If no package is specified, "main" is assumed. A `module-info.sy` file is not
 * required for the top level program as there is an inferred `main` module that
 * contains top-level programs.
 */
package main

/*
 * Most of those imports are already in the prelude and thus already imported:
 * `sylan.lang`. They are explicitly imported here to give an idea of the standard
 * package structure.
 */
import sylan.io.println
import sylan.util.toString.ToString
import sylan.util.collections.{HashMap, List}
import sylan.util.concurrency.Task
import sylan.util.datetime.ZonedDateTime
import sylan.util.optional.{Empty, Some}

void demoIteration() {
    /**
     * SyDocs can be written for code documentation. Unlike JavaDoc but similar
     * to Python, they go inside the item they describe rather than before it.
     */

    List(1, 2, 3).forEach(n ->

        /*
         * Backquoted strings allow interpolation. Only single symbols can be
         * interpolated; interpolating arbitrary expressions was purposely
         * omitted due to its ability to create cryptic one-liners.
         */
        println(`{n}`)
    )

    var highlight = s -> `>> {s} &lt;&lt;`

    1.to(5)
        .map(Number::double # ToString::toString # highlight)
        .forEach(println)

    var quadruple = n -> n.double().double()

    123456789
        |> quadruple
        |> Object::toString
        |> highlight
        |> println

    var map = HashMap(
        "abc": 123,
        "def": 321,
        "ghi": 987,
    )
    map.forEach((key, value) ->
        println(`{key}: {value}`)
    )

    /*
     * Sylan does not allow scope shadowing. As functions are just
     * variables of a "function type", `factorial` would clash with the
     * top-level `factorial` function defined later on, hence the disambiguating
     * name `innerFactorial`.
     */
    var innerFactorial = for var n = 20, var result = 1 {
        if n &lt;= 0 {
            result
        } else {
            continue n - 1, n * result
        }
    }

    OUTER: for var n = 10 {
        if 0 &lt; n {
            for {

                // A `for` with no clauses is an infinite loop, except for the
                // use of a continue label here that lets it jump to an outer
                // loop.
                OUTER: continue n - 1
            }
        }
    }

    println(`factorial: {innerFactorial}`)
}


/*
 * All variables (including functions), packages, classes, getters, fields,
 * and methods are private unless explicitly opened up with the `public`
 * keyword. If the developer wants to expose them openly but only to
 * its own module, they can use the `internal` keyword.
 *
 * As can be seen in this function and the previous, Sylan allows functions to
 * stand alone in packages without being tied to classes or interfaces.
 */
internal int factorial(int n) {
    switch n {
        0, 1 ->
            1
        n if n &lt; 0 ->
            throw Exception("n cannot be less than 0")
        n ->
            /*
             * Guaranteed tail call elimination will ensure a stack overflow
             * does not occur.
             */
            factorial(n * (n - 1))
    }
}

ignorable internal int printFactorial(int n) {
    /*
     * Sylan does not allow callers to throw away non-`void` function or methods
     * results unless they're declared with the `ignorable` modifier.
     *
     * This makes sense when getting a return value is potentially useful but
     * not the entire reason behind invoking it.  Such a function or method can
     * be assumed to have side effects, with the exception of constant-time
     * operation NOPs or the like.
     */

    var result = factorial(n)
    println(result)

    /*
     * Sylan is an expression-oriented language, so everything returns a value
     * including loops and `if`s. Therefore, the last value is returned by
     * default. The lack of explicit `return`s mean there is always a single
     * exit point from a function or method: the last expression.
     */
    result
}

private void twice&lt;N>(N n, N f(N)) where
    N : Number
{
    f(n) + f(n)
}

String double&lt;N>(N n) where
    N : Add & ToString
{
    (n + n).toString()
}

Optional&lt;int> demoContexts() {

    /*
     * Haskell programmers will recognise this as a monadic do notation, which
     * Sylan calls "contexts". Non-Haskell programmers will be glad to know that
     * this feature can make tangled code such as optionality-checking chains
     * and validation code much cleaner.
     */
    do {
        var a &lt;- Some(5)
        doSomething()
        var b &lt;- Empty()
        willNotBeRun()
    }
}

package counter {

    enum Message {
        Increment,
        Reset(int),
        Get,
    }

    public void start(Task sender, int n = 0) {
        select Message {
            .Increment:
                start(sender, n + 1)
            .Reset(n):
                start(sender, n)
            .Get:
                sender.send(n)
                start(sender, n)
            timeout 10.seconds:
                throw Exception("timed out!")
        }
    }
}

interface Concatenate&lt;T, Result = T> {
    public Result concatenate(T y)
}

interface Equals&lt;T = Self> {
    public boolean equals(T other)

    /*
     * Sylan's interface methods can have bodies like Java 8's defender methods.
     * Unlike Java 8, private methods with bodies are also allowed with the
     * `default` keyword. Similar to C# but unlike Java, a default method body
     * in an interface can only be overridden if annotated with `virtual`.
     *
     * `virtual` is default for non-default methods since the lack of concrete
     * inheritance in Sylan means there is no other possible use case for them
     * except to be implemented by the implementor.
     */
    public default virtual notEquals(T other) {
        !equals(other)
    }
}

class Name {
    /**
     * Getters, hashing, equality checking, and the constructor all just exist
     * automatically. They can still be manually overridden if necessary though.
     * `close` is also automatically implemented for classes that implement
     * `AutoCloseable`, the default implementation just closing all
     * `AutoCloseable` fields. This can also be overridden if the default
     * implementation makes no sense.
     */

    internal String firstName
    internal String lastName
}

class Account implements ToString, Concatenate&lt;Account> {
    /**
     * Classes can implement interfaces but cannot extend other classes.
     * Interfaces can extend other interfaces though. Concrete inheritance
     * generally causes more problems that it's worth and type embedding plus a
     * more powerful interface system makes up for the difference.
     */

    /*
     * Embedding a field hoists all of its _accessible_ methods and getters into
     * the class itself. Embedded methods take the lowest priority: methods in
     * the class itself and default methods in implementing interfaces both take
     * priority over embedded methods, although other embedded methods will
     * still call the embedder's method if calling it by name.
     *
     * As getters are also embedded, it can look awfully close to multiple
     * inheritance of state, but is not due to the lack of mutability and the
     * fact that only one getter of each given name and type can emerge from the
     * prioritisation.
     *
     * Embedded classes can implement methods for implementing interfaces on the
     * embedder's behalf, following the rules above.
     *
     * Note that no relationship whatsoever is established between the classes
     * after the embedding; there is no concrete subtyping in Sylan. It's solely
     * for DRY, a.k.a. Don't Repeat Yourself.
     *
     * The earlier embeddings take priority over the later ones, to be
     * consistent with the MRO of inheritance. Therefore, changing the order of
     * embeds can change behaviour.
     */
    embed Name name

    int ageInYears

    ZonedDateTime _expiry = ZonedDateTime.now() + 1.year

    public Account(String firstName, String lastName) {
        println("instantiating an Account...")

        /*
         * Constructors are the only place in Sylan where assignments are
         * allowed outside the context of a binding.
         */
        name.firstName = firstName
        name.lastName = lastName
        ageInYears = 35
    }

    public override String toString() {
        `{firstName} {lastName} is {ageInYears} years old`
    }

    public override Account concatenate(Account a) {
        var firstName = firstName.concat(a.firstName)
        var lastName = lastName.concat(a.lastName)

        Account(
            .firstName,
            .lastName,
            ageInYears = ageInYears + a.ageInYears,
        )
    }

    /*
     * Getters are defined like methods but look like fields. Setters don't
     * exist because Sylan is an immutable language.
     */
    public String get name {
        `{firstName} {lastName}`
    }

    public boolean get locked {
        expiry &lt; ZonedDateTime.now
    }
}

/*
 * Type extensions allow modules to add their own features to an existing class
 * when imported. Note that this implements `Concatenate` again just with
 * different type parameters passed to `Concatenate`; Sylan considers these to
 * be two completely different implementations. This is a more disciplined
 * replacement for method overloading.
 */
extend class Account implements Concatenate&lt;Account, Result = String> {

    public override String concatenate(This that) {
        `{firstName} {that.firstName}`
    }
}

void demoPatternMatching() {
    var account1 = Account(firstName = "Tom", lastName = "Smith")
    var matchingLastName = "Smith"

    if var Account(firstName, lastName = .matchingLastName) as account
            = account1 {
        println(`Matching first name: {firstName}`)
        println(`Matching account: {account}`)
    }

    switch account1 {

        Account(locked = true), Account(firstName = "unlucky") ->
            println("LOCKED!")

        Account(expiry) if expiry &lt; ZonedDateTime.now ->
            println("ALSO LOCKED")

        default {
            println("NOT LOCKED: ")
            println(account1)
        }

        /*
         * Switches are expressions, support multiple cases, can do pattern
         * matching, and have support for conditional "guards".
         */
    }
}

/*
 * Aliasing of various constructs to allow easy code repair during large-scale
 * refactoring. Any item in any module can be aliased, which can ease module
 * versioning where new major module versions are effectively different modules.
 */
alias counter2 = counter
alias Person = Account
alias Showable = ToString
alias factorial2 = factorial

int maxBound = 5

void demoClosures() {
    var x = 5

    var account1 = Account(
        firstName = "Tom",
        lastName = "Smith",
        ageInYears = 15,
    )

    var firstName = "Tom"
    var lastName = "Smith"
    var age = 25
    var account2 = Account(.firstName, .lastName, ageInYears = age)

    var f = a ->
        println(a.toString())

    f(account1)
    f(account2(firstName = "Emma"))

    var g = a -> {
        println("returning an account")
        a
    }

    var z = g(account1)

    var n = twice(3, x -> x * 2)
    println(`n == {n}`)
}

class NumericLiteralsClass implements ToString {

    // Non-overflowable numbers.
    int a = 5
    uint b = 5u
    decimal c = 10.0

    // Overflowable, machine-width numbers.
    byte d = 5u8
    uint16 e = 11u16
    uint32 f = 12u32
    uint64 g = 13u64
    int8 h = 15s8
    short i = 13s16
    int32 j = 7s
    long k = 7s64
    float l = 12f
    double m = 8f64

    public override String toString() {
        `{a}{b}{c}{d}{e}{f}{g}{h}{i}{j}{k}{l}{m}`
    }
}

class AutoCloseableDemo implements AutoCloseable {

    public AutoCloseableDemo() {
        println("Opened")
    }

    public override void close() {
        println("Closed")
    }
}

void demoAutoCloseables() {

    /*
     * Sylan, like Erlang and Go, strongly discourages catching exceptional
     * problems on a routine basis - if something is truly "exceptional" then
     * the developer wouldn't have thought of a meaningful response to it.
     * Instead it encourages assertive programming through a "happy path" and
     * using supervisor tasks to allow the system to heal from unexpected
     * failures.
     *
     * Sylan does not offer `try`/`catch` for this reason, and also to ensure
     * that exception-driven control flow isn't possible.
     *
     * However, there still needs to be a strategy regarding closing resources
     * in tasks that have had unexpected failures. Sylan offers `AutoClosable`
     * types and the `try` keyword for this, which are a sort of middle ground
     * between Java's `AutoCloseable` and try-with-resources feature and Go's
     * `defer` keyword.
     *
     * If an `AutoCloseable` type is prefixed with the `try` keyword, its
     * `close` method is invoked at the end of the scope _even if the
     * code in the scope completely fails unexpectedly_. The closing is done in
     * the reverse order that they are set up. If any `defer`d `close` methods
     * themselves fail, all other deferred calls are given a chance to run too,
     * and all errors are accumulated into one and rethrown once they're all
     * finished.
     */

    println("Entering scope")
    {
        var closeable = try AutoCloseableDemo()
        println("Using closeable")
    }
    println("Leaving scope")

    // Prints "Entering scope", "Opened", "Using closeable", "Closed", and finally "Leaving scope".
}

void demo() {
    demoIteration()

    printFactorial(42)
    var x = twice(4, double)
    println(`{x}`)

    demoContexts()
    demoPatternMatching()
    demoClosures()

    println(NumericLiteralsDemo().toString())

    demoAutoCloseable()
}

/*
 * Top-level code is allowed, but only in the main package within the main
 * module. Code in other packages must be in functions or methods.
 */

var optionalString = Some("test string")
if var Some(s) = optionalString {
    println(s)
}

var c = Task(-> counter.start(currentTask))
5.times(-> c.send(counter.Message.Increment()))

c.send(counter.Message.Get())
c.send(counter.Message.Increment())
c.send(counter.Message.Get())

// Should print 5 and then 6.
2.times(->
    select int n {
        println(`{n}`)
    }
)

print("""
Multiline
strings
""")

var x = {
    println("Returning 5 to be bound as x...")
    5
}
println(`{x}`)

/*
  A multiline comment.

  /*
    A nested multiline comment.
  */
*/

demo()
</pre>

<h2 id="synopsis">Synopsis</h2>

<p>
Java and C# moved C++ application programmers away from direct memory
management onto managed abstract machines with concurrency, networking,
serialisation, and portability built-in.
</p>

<p>
What about the next language and runtime after Java and .NET? Better distributed
and concurrent programming support would be a good starting point. Null-free
types, ubiquitous immutability, a lack of concrete inheritance, built-in
    supervisor trees, and transparently non-blocking IO would acknowledge this era
of computing.
</p>

<p>
Hardware is no longer speeding up exponentially year-on-year and is becoming
increasingly parallel. Performance cannot be discarded out of hand like the rise
of dynamic languages throughout the previous decade.
</p>

<p>
Large semantic changes will likely be rejected by developers if not presented in
    a syntax similar to existing languages; like Java and C# took C++'s syntax, the
    next language should take Java's and C#'s.
</p>

<p>
A gap exists between scripting languages and application languages; would enough
type inference and support for features like top-level executable code and
shebangs help bridge the gap to allow both to be done in one language?
</p>

<p>
Strong isolation boundaries at modules and explicitly declared dependent modules
and their full versions are required to evolve large systems over time without
breaking compatibility. Major version changes, according to semantic versioning,
are breaking changes, and should therefore be considered completely different
modules. Non-pinned dependency versions or disallowing the import of multiple
major versions of the same module does not scale in the modern world of software
development.
</p>

<p>
A runtime will be needed for preemptive concurrency and light weight tasks.
Go shows that compromises regarding the tasks' preemptiveness must be made in
the case of native compilation.
</p>

<h2 id="todo">TODO</h2>

<ul>
  <li class="done">Lex.</li>
  <li>Parse.</li>
  <li>Implement the runtime.</li>
  <li>Interpret without any checks.</li>
  <li>Add checks such as types.</li>
  <li>Add optimisations like persistent data structures.</li>
  <li>Compile with bundled runtime.</li>
</ul>

<h2 id="goals">Goals</h2>

<ul>
  <li>Look as syntactically similar to Java and C# as possible.</li>
  <li>
    Support mixed-ability teams by not adding footguns or abstractions that do
    not scale; powerful features should have very little action-at-a-distance.
    Computer science concepts are trumped by real world, large-scale software
    engineering concerns.
  </li>
  <li>
    Use null-free static types and increase type-system expressiveness over Java
    and C#.
  </li>
  <li>
      Make tool and IDE integration as easy as possible. Perhaps an FFI into the
      final parser and compiler and an initial Language Server Protocol
      implementation.
  </li>
  <li>
    Focus on AOT compilation for ease of distribution, Go- and Rust-style.
    Support interpretation for embedding, quick debugging, and interactive
    development.
  </li>
  <li>
    Use ubiquitous immutability to reduce unnecessary side-effects and coupling;
    invalid states should be unrepresentable.
  </li>
  <li>Allow distributed programming with message-passing.</li>
  <li>Transparently handle asynchronous IO.</li>
  <li>
    Make tasks cheap, preemptive, and killable; tasks should be a useful
    abstraction, not like threads which are a low-level OS-provided feature with
    endless edge cases.
  </li>
  <li>
    Remove or fix error-prone features from Java and C#, like
    assignments-as-expressions, pre and post decrement and increment, nulls,
    concrete inheritance, pervasive mutability, type erasure, statics,
    primitives and autoboxing, default memory sharing across tasks, and in-task
    catchable exceptions.
  </li>
  <li>
    Non-overflowable arithmetic should be default; machine-width arithmetic as
    an opt-in for performance.
  </li>
  <li>
    Encourage compile-time metaprogramming over runtime annotation and
    reflection; design it to scale in the large without becoming cryptic.
  </li>
  <li>Be mostly expression-based and with decent pattern matching.</li>
  <li>Guarantee tail-call elimination.
</ul>

<h2 id="details">Details</h2>

<h3 id="details-modules-and-packages">Modules and Packages</h3>

<ul>
  <li>Packages live within modules.</li>
  <li>
    Modules are the most coarse encapsulation boundary developers have.
  </li>
  <li>
    Package are for laying out the structure of modules.
  <li>
    There is an implicit <code>main</code> module and <code>main</code> package.
    The implicitness is to reduce boilerplate for single-line programs and
    scripts.
  </li>
  <li>
    Programs must be in a <code>main</code> module and a <code>main</code>
      package, but libraries must have their own unique modules names.
  </li>
  <li>Modules, unlike packages, are versioned.</li>
  <li>They declare which packages they depend on.</li>
  <li>
    Only items that are public and all of whose parents are also public are
    exposed.
  </li>
  <li>
    The <code>internal</code> accessibility modifier allows making something
    public to other packages, but only within the module.
  </li>
  <li>
    A different major version of a module is effectively considered a different
    module in practice. In fact, multiple major versions of the same module can
    be required at once. Cross-module aliases can be used to gradually evolve
    major package versions over time without breaking compatibility.
  </li>
  <li>
    Leaving a version number out assumes 0.x. Major version 0 is the only
    version for which breaking changes across minor versions is acceptable.
  </li>
  <li>
    The use of private-by-default accessibility combined with no reflection or
    runtime metadata should give some decent oppertunities for dead-code
    elimination and inter-procedural optimisations within a module.
  </li>
</ul>

<h3 id="details-accessibility-levels">Accessibility Levels</h3>
<ul>
  <li>Private, internal, and public.</li>
  <li>
    Private is the default, no keyword required.
  </li>
  <li>
    The <code>internal</code> keyword exposes an item to its parent, but only
    within its module.
  </li>
  <li>
    The <code>public</code> keyword exposes an item to its parent, available
    from outside the module too.
  </li>
</ul>

<h3 id="details-items-and-expressions">Items and Expressions</h3>

<ul>
  <li>Items declare rigid, static program structure.</li>
  <li>Expressions express computations and are obviously Turing complete.</li>
  <li>
    Items can contain expressions, i.e. a method item containing a method body
    with expressions.
  </li>
  <li>
      Expressions cannot contain items, with one exception: let bindings within
      lambdas expressions.
  </li>
</ul>

<h3 id="details-types">Types</h3>

<ul>
  <li>Built-ins and user-defined.</li>
  <li>
    No difference between them from the user's perspective except for some of
    them having literals baked into the language  and built-ins being predefined
    by the compiler and runtime. No Java-like primitive vs object distinction.
  </li>
  <li>
    Constructors are special; this is done to allow function-style
    instantiations while avoiding things like statics, needing to detach
    constructors from class definitions, or having a more complicated
    initialisation syntax.
  </li>
  <li>
    <code>void</code> is an actual type, like <code>()</code> in Haskell.
    Defining a method as returning <code>void</code> is a special-case that
    discards the result of final non-void expression and returns the void value
    instead. Every function returning a value, rather than having "procedures"
    without return values, avoids special-cases when composing functions in
    various ways.
  </li>
  <li>Generics like C#, as in no type erasure.</li>
  <li>
    Support higher-kinded types, but keep an eye on projects like Dotty to see
    what type-soundness issues they encounter. Perhaps implement a more
    restricted version of it.
  </li>
  <li>
      While public fields are encouraged, unlike Java Sylan can add getters to
      intercept them at a later date without breaking API compatibility. This
      makes it fine to expose fields publicly. Setters do not exist due to Sylan
      being a fully immutable language.
  </li>
</ul>

    <h3 id="details-type-hierarchy">Type Hierarchies</h3>
    <ul>
        <li>
            Final classes and trait-like interfaces. No concrete inheritance or
            abstract classes. Discourages "type taxonomy".
        </li>
        <li>
            <code>super</code> is to either disambiguate which interface's method to
            delegate to, or to fallback to the auto-generated constructor or other
            auto-generated method like <code>hashcode</code> or <code>equals</code> in
            user-defined constructors and methods. It does not deal with concrete class
            inheritance.
        </li>
        <li>
            Interfaces can provide default method implementations, which can be
            overridden in implementing classes if they are <code>virtual</code>.
            <code>override</code> on a method in a implementing class documents that it
            must override rather than just shadow. Method shadowing by default, while
            problematic in some areas, allows interfaces to add new virtual default
            methods over time without breaking backwards compatibility with implementors
            that already define their own methods of the same name. "Shadowing" is when
            a method occupies that name in a class' own other methods but does not
            override calls to that method name in the interfaces' default methods.
        </li>
        <li>
            Method resolution is done via Dylan- and Python 3-inspired MRO rather than
            forcing explicit disambiguation like Java 8's defender methods. This is done
            to ensure that default method additions do not break backwards compatibility
            with implementing types that potentially implement another interface that
            has a method compatible with the newly added method, causing a diamond
            inheritance clash. See
            <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 linearization</a>.
        </li>
    </ul>

    <h3 id="details-type-embedding">Type Embedding</h3>

    <ul>
        <li>
            The <code>embed</code> keyword allows classes to embed other classes. This
            just takes all methods and and getters of a class and hoists them to the
            top level of the class itself. Fields must still be accessed via the field
            itself, however.
        </li>
        <li>
            If multiple embeds embed a getter or a method of the same signature, the
            earliest one takes priority. This is to follow the first-takes-priority
            system characteristics of MRO in inheritance, and to avoid
            backwards-compatibility breakages caused by the addition of new methods or
            getters to embedded types.
        </li>
        <li>
            There is no sub-typing relationship established by embedding whatsoever.
            Sylan does not support subtyping.
        </li>
    </ul>

    <h3 id="details-type-inference">Type Inference</h3>
    <ul>
        <li>
            Only nominal types, no structural types. While it would be nice to mandate
            that all type inference should be derivable from inner expressions outwards
            without going the other way, that isn't possible due to constructs like
            immediately-invoked lambdas or lambdas with parameters being passed as
            a parameter typed as a lambda that takes compatible but more precise types.
        </li>
        <li>
            Once we allow that, there's no reason not to allow LHS type inference to
            flow from the RHS as long as it only flows to declarations within a function
            or method body and does not escape it.
        </li>
        <li>
            Sylan is more opinionated than most language on how to use type annotations:
            all items should be 100% explicitly typed whereas all declarations scoped to
            a method or function should be 100% implicitly typed. The language will not
            expose edge cases where type annotations are ever actually necessary in
            method or function bodies (like the "<code>:: Float</code> to disambiguate
            <code>Show</code>" problem of Haskell). This is why numbers have explicit
            type suffixes.
        </li>
        <li>
            This ensures APIs and program structure is rigid and explicitly typed while
            expressions are concise, without boilerplate, and utterly consistent rather
            than making type annotations a matter of taste.
        </li>
    </ul>

<h3 id="details-language-versioning">Language Versioning</h3>

<ul>
  <li>Keyword <code>v</code> can start a file to denote the source version.</li>
  <li>Has a version after it, e.g. <code>v1.0</code></li>
  <li>
    If not present, assume to be the latest minor version of the earliest major
    release of the language, i.e. 1.x.
  </li>
  <li>
    Three things are versioned: the source, the tokens, and the AST.
  </li>
  <li>
    A source version pins its tokens version; a tokens version pins its AST
    version. So the versioning between the three isn't neccessarily in lockstep,
    but it is fixed.
  </li>
</ul>

<h3 id="details-methods-and-functions">Methods and Functions</h3>

<ul>
  <li>
    Purposely different from one another; there isn't a UFC mechanism that
    unifies them.
  </li>
  <li>
    Both are fully higher-order. Methods carry around their instances with them.
  </li>
  <li>
    Methods, when passed around as values, are just seen as functions that have
    an instance bundled in their closure.
  </li>
  <li>
      <code>Class::method</code> is a shorthand for <code>(o, ...args) ->
      o.method(...args)</code>, where the type of <code>o</code> is
      <code>Class</code>.
  </li>
  <li>
    As methods and functions are both higher-order, invoked the same way, and
    have the same type when passed around, there is no real loss of
    composibility from being different constructs. They can be composed together
      easily: <code>var printDouble = Number::double # ToString::toString #
      println</code>.
  </li>
</ul>

<h3 id="details-pattern-matching">Pattern Matching</h3>

<ul>
  <li>Literals are matched as is.</li>
  <li>
    Composite types are matched as <code>Type(field1, field2 = match2,
    getterValue)</code>.
  </li>
  <li>Public fields and getters can be used.</li>
  <li>
    An identifier by itself is a shorthand for <code>identifier =
    identifier</code>.
  </li>
  <li>There are no positional matches, only matches by specific names.</li>
  <li>
    For types not overriding the built-in constructor, destructuring should be
    symmetrical with constructing.
  </li>
  <li><code>...</code> can be used to omit the rest of the match.</li>
  <li>
    <code>as</code> can bind part of a match to a name, e.g.
    <code>Account(firstName) as account</code>.
  </li>
  <li>
    Prefixing an identifier with a dot matches its value rather than binding
    against the identifier, e.g: <code>Account(firstName = .enteredFirstName,
    ...)</code>.
  </li>
</ul>

<h3 id="details-matching-in-switch-and-select">Matching in Switch and Select</h3>

<ul>
  <li>
      They both have cases which each match one or more patterns separated by
    commas.
  </li>
  <li>
    Both have <code>default</code> clauses as a fallback "match all" clause.
  </li>
  <li>
    <code>switch</code> is exhaustive: a compiler error happens if not all cases
    are covered.
  </li>
  <li>
      <code>select</code> is non-exhaustive, sending non-matching messages to the
      <code>noReceiver</code> task's mailbox (whose behaviour can be manually
      overridden).
  </li>
  <li>
    <code>select</code> blocks the current task until someone sends the process
    a message of the specified type with a match. <code>timeout</code> clauses
    are available.
  </li>
</ul>

<h3 id="details-invocations">Invocations</h3>

<ul>
  <li>
    Methods, functions, classes, and objects can be invoked with
    <code>()</code>.
  </li>
  <li>
    Invoking a method or a function does as one would expect; invoking a class
    constructs an instance; invoking an object allows non-destructive
    updates.
  </li>
  <li>Arguments can have default values.</li>
  <li>
    Any argument can be invoked as either positional or keyword; it's up to the
    caller.
  </li>
  <li>
    Two special parameter types exist: variadic and variadic entry. The former
    allows an variable amount of arguments, whereas the latter allows a variable
    amount of <code>sylan.lang.Entry</code> arguments with syntactical sugar.
    The latter is primarily for providing a good syntax for constructing map
    types that user-defined types can use.
  </li>
  <li>
    Prefixing an argument with a dot is a shortcut for assigning a keyword
    argument from a binding of the same name, e.g.
    <code>Account(.firstName)</code> is <code>Account(firstName =
    firstName)</code>.
  </li>
  <li>
    Passing <code>_</code> for one or more arguments partially applies the
    invocation, returning a new function with the non-underscore arguments
    evaluated and partially applied to the result. This allows, for example,
    partially-applying a non-destructive object update, partially applying a
    function, or partially-applying the instantiation of a class.
  </li>
</ul>

<h3 id="details-compile-time-metaprogramming">Compile-time Metaprogramming</h3>

<ul>
  <li>
    No <code>constexpr</code>, templating, or <code>static if</code>. Should be
    the same language as runtime.
  </li>
  <li>
      Derive from Lisp and Jai but reduce foot guns like Common Lisp automatic
    variable captures.
  </li>
  <li>Do not copy D or C++.</li>
  <li>Will eliminate the need for reflection.</li>
  <li>
    What are the security implications of running arbitrary code from the
    compiler? Surely we should at least ban system side-effects?
  </li>
  <li>
    CL's <code>defmacro</code> is too low-level; a Java-like annotation syntax
    could be used for a more controlled subset, perhaps hygienic macro system a
    la Scheme.
  </li>
  <li>
    Macros can only be invoked against a specific tokens version or an AST
    version. The compiler just won't compile macros designed for a v2 AST when
    invoked against a v3 source.
  </li>
</ul>

<h3 id="details-runtime-structure-information">Runtime Structure Information</h3>

<ul>
  <li>No reflection.</li>
  <li>No runtime annotations.</li>
  <li>Use compile-time programming instead.</li>
  <li>
    Reduces magic, as compile-time metaprogramming cannot happen at random
    points during a running application unless <code>eval</code> exists.
  </li>
  <li>Improves performance as metaprogramming is done at compile-time.</li>
</ul>

    <h3 id="details-resource-management">Resource Management</h3>
    <ul>
        <li>
            Closable resources like file handles are managed consistently via the
            <code>AutoCloseable</code> interface.
        </li>
        <li>
            The <code>try</code> keyword can prefix any <code>AutoCloseable</code>
            value, in which case it is guaranteed to close at the end of the scope even
            if the current task fails.
        </li>
        <li>
            All <code>try</code>`d values are guaranteed to have a chance to run their
            close method, even if one of them fails before all are complete.
        </li>
        <li>
            They are closed in the order they were set up, reversed.
        </li>
    </ul>

    <h3 id="details-the-runtime">The Runtime</h3>

<ul>
  <li>It will probably be heavily BEAM-inspired.</li>
  <li>Must do tail call elimination.</li>
  <li>No mutable data except the execution of tasks over time.</li>
  <li>
    Lightweight processes. Immutability means changes can only be sent via
      messages or tracked via services external to the Sylan program.
  </li>
  <li>
    Initial toy implementation to use threads. Real implementation can use
    userland scheduler with remote process support.
  </li>
  <li>To handle remote processes, Tasks need node IDs.</li>
  <li>...and nodes need network addresses or localhost.</li>
  <li>
    Per-task GC in theory; probably global GC in first implementation for
    simplicity. (Perhaps that's OK if only a single task's world gets stopped
    at any time.)
  </li>
  <li>
      Persistent data structures, which should be definable as a library rather
      than baked into the language itself.
  </li>
  <li>
    Async IO; use a library like Tokio. OK to block in the prototype, but don't
    add any language features that break compatibility with async in the proper
    version.
  </li>
</ul>

<h3 id="details-the-build-system">The Build System</h3>

<ul>
  <li>
    Go-style; just derive information from the source files rather than using
    separate configurations.
  </li>
  <li>
    Strong compile-time metaprogramming can assist here, similar to how Jai
    replaces Makefiles with compile-time profiles.
  </li>
</ul>

<h3 id="details-interoperability">Interoperability</h3>

<ul>
    <li>
        <code>extern</code> allows calling functions that are either statically
        linked in or via a named dynamically linked library.
    </li>
    <li>
        Public exposed symbols in Sylan are accessible by either statically
        linking the result into another executable or by creating a dynamically
        linked library when building the Sylan program and then referring to it
        dynamically from other executables.
    </li>
    <li>
        As Sylan does not support ad hoc overloading, all demangling is
        straightforward. One underscore denotes a package change while two
        indicate a method belonging to a type. E.g.:
        <code>sylan.util.collections.HashMap#put</code> becomes
        <code>sylan_util_collections_HashMap__put</code>.
    </li>
  <li>
    Lightweight tasks will be awkward with POSIX/WinNT threads for native
      interoperability; see Erlang and Go's issues here. Not sure of a better
      alternative if we're using userland stacks and scheduling. Entering and
      exiting Sylan from non-Sylan code will probably require allocating threads
      allocated solely to avoid blocking in foreign code blocking the Sylan
      runtime.
  </li>
</ul>

<h3 id="details-standard-library">Standard Library</h3>

<ul>
  <li>
      Standard lib should be modular, like Java 9's JRE.
  </li>
</ul>

<h3 id="details-to-consider">To Consider</h3>

<ul>
  <li>
    Parameterisable packages, perhaps a less powerful version of ML functors.
  </li>
  <li>
    Matrix operations to implement for user types, even if builtins do not use
    them. See Python 3 for an implementation of this.
  </li>
  <li>
      Subtyping for built in types, like subranges across integers, Ada-style?
  </li>
    <li>Multiversal equality rather than universal equality.</li>
    <li>
        Reject changes that break backwards compatibility if the major version
        isn't bumped, similar to Elm.
    </li>
    <li>
        Replace auto-generated methods with a more consistent
        <code>derives</code>/<code>deriving</code> approach, a la Rust and Haskell.
    </li>
</ul>

<h2 id="implementation-details">Implementation Details</h2>

<p>
For more documentation on the actual implementation of Sylan, read the Rust
    documentation comments of the code. A good starting point is the documentation
    of <a href="https://github.com/LouisJackman/sylan/blob/master/src/main.rs">the
    main top-level source file</a>.
</p>

</main>
</body>
